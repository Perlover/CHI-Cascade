=encoding utf8

=pod

=head1 NAME

CHI::Cascade - модуль кеш - зависимостей ( совмещает кеширование и принципы утилиты make )

=head1 SYNOPSIS

    use CHI;
    use CHI::Cascade;

    $cascade = CHI::Cascade->new(chi => CHI->new(...));

    $cascade->rule(
	target	=> 'unique_name',
	depends	=> ['unique_name_other1', 'unique_name_other2'],
	code	=> sub {
	    my ($rule, $target_name, $values_of_depends) = @_;

	    # $values_of_depends == {
	    #     unique_name_other1 => $value_1,
	    #     unique_name_other2 => $value_2
	    # }
	    # $rule->target	eq	$target_name
	    # $rule->depends	===	['unique_name_other1', 'unique_name_other2']
	    # $rule->dep_values	==	$values_of_depends
	    # $rule->params	==	{ a => 1, b => 2 }

	    # Now we can calcualte $value
	    return $value;
	},
	params	=> { a => 1, b => 2 }
    );

    $cascade->rule(
	target	=> 'unique_name_other1',
	depends	=> 'unique_name_other3',
	code	=> sub {
	    my ($rule, $target_name, $values_of_depends) = @_;

	    # $values_of_depends == {
	    #     unique_name_other3 => $value_3
	    # }

	    # computing here
	    return $value;
	}
    );

    $value_of_this_target = $cascade->run('unique_name');

=head1 DESCRIPTION

Этот модуль представляет симбиоз кеширования и принципов вычислений на основе
зависимостей. Главная задача написания его была получить выгоду от кеширования,
связей зависимостей, и при этом чтобы была возможность получать данные, на
вычисления которых уходит значительное количество времени. При этом самым
главным было бы то, чтобы к этим данным могли обращаться одновременно много
клиентов, и они с максимальной отдачей получали бы самые свежие расчитанные
данные, не загружая при этом систему. При этом нагрузка на пересчет ложится
только на какого либо одного клиента, в то время как другие в этот момент
получают либо старые данные, либо получают мгновенно отклик "повторить снова". А
зависимости targets, которые определяют что от чего зависит, позволяют свести к
минимуму количество шагов пересчета.

Для реализации такой схемы модуль хранит в кеше два элемента: target метку и
само значение вычисленного target. Target метка очень компактна и за счет нёё
отслеживаются зависимости. Само значение хранится в serialized виде в другом
элементе кеша.

=head1 CONSTRUCTOR

$cascade = CHI::Cascade->new( %options )

Этот метод конструирует C<CHI::Cascade> instance и возвращает её.
Ему можно передать следующие опции

=over

=item chi

Обязательное. Instance объекта L<CHI> object. Объект CHI вы должны создать сами,
указав нужные вам опции. Например, можно организовать файловый кеш, memcached
кеш и даже зеркальный кеш.

=item busy_lock

Опционально. По умолчанию I<never>. I<Это не опция C<busy_lock> CHI!> Это
количество времени (смотрите L<CHI/"DURATION EXPRESSIONS">), по истечении
которого истекает target локировка в случаях, когда произошли непредвиденные
операции (например, аварийное завершение программы). Рекомендуется выставлять
его для целого объекта CHI::Cascade, либо для отдельных rules. Если случиться
мертвая локировка target, то спустя это время CHI кеш посчитает её истекшей и
ваш пересчет повториться.

=back

=head1 METHODS

=over

=item rule( %options )

Добавляет новое правило в C<CHI::Cascade> объект. Все правила должны быть добавлены перед первым вызовом L</run>

Опции %options данного метода:

=over

=item target

B<Обязательно.> Цель (target) для метода L</run> и для зависимостей L</depends>
в правилах. Может быть как обычным текстовым значением, так и C<Regexp> объектом
созданным через C<qr//>

=item depends

B<Опционально.> Должно быть одним из трёх типов: B<scalar>, B<arrayref> или
B<coderef>. Оно определяет список зависимостей, от которых зависит цель,
определяемая данным правилом Может быть одним из типов:

=over

=item scalar

Содержит имя только одной цели-зависимости, от которой зависит данная цель.

=item arrayref

Массив целей-зависимостей. Каждый элемент может быть либо scalar типом,
указывающим в точности на цель-зависимость, либо coderef (ссылка на функцию).
Если последний тип, то для получения целей-зависимостей, CHI::Cascade вызовет
эту функцию как $coderef->( $rule,
L<$rule-E<gt>qr_params|CHI::Cascade::Rule/qr_params> ) и она должна вернуть
scalar значение - точное название цели-зависимости во время исполнения (runtime)

=item coderef

Эта функция бует исполняться каждый раз внутри L<CHI::Cascade/run> метода со
следующими параметрами: $coderef->( $rule,
L<$rule-E<gt>qr_params|CHI::Cascade::Rule/qr_params> ). Она должна вернуть либо
B<scalar>, либо B<arrayref>. Если B<scalar>, то оно будет расцениваться как
единственное имя цели-зависимости и поведение cascade будет в точности, как
описано выше для I<scalar> типа, описанного выше в данном параграфе. Если
возвращённое значение I<arrayref>, оно будет рассматриваться как список
целей-зависимостей - смотренно описание для I<arrayref> в данном параграфе

=back

=item code

B<Required.> The code reference for computing a value of this target. Will be
executed if no value in cache for this target or any dependence or dependences
of dependences and so on will be recomputed. Will be executed as $code->( $rule,
$target, $hashref_to_value_of_dependencies ) I<(The API of running this code was
changed since v0.10)>

=over

=item $rule

An instance of L<CHI::Cascade::Rule> object. You can use it object as accessor
for some current executed target data (plain text of target, for getting of
parameters and so on). Please to see L<CHI::Cascade::Rule>

=item $target

A current target as plain text (what a target the $cascade got from L<run>
method)

=item $hashref_to_value_of_dependencies

A hash reference of values of all dependencies for current target. Keys in this
hash are flat strings of dependecies and values are computed or cached ones.

This module should guarantee that values of dependencies will be valid values
even if value is C<undef>. This code can return C<undef> value as a valid code
return but author doesn't recommend it. If C<CHI::Cascade> could not get a valid
values of all dependencies of current target before execution of this code the
last will not be executed (The C<run> will return C<undef>).

=back

=item params

You can pass in your code any additional parameters by this option. These
parameters are accessed in your code through L<params|CHI::Cascade::Rule/params>
method of L<CHI::Cascade::Rule> instance object.

=item busy_lock

Optional. Default is L</busy_lock> of constructor or I<never> if first is not
defined. I<This is not C<busy_lock> option of CHI!> This is amount of time (to
see L<CHI/"DURATION EXPRESSIONS">) until target lock expires. When a target is
recomputed it is locked. If process is to be recomputing target and it will die
or OS will be hangs up we can dead locks and locked target will never recomputed
again. This option helps to avoid it.

=back

=item run( $target )

This method makes a cascade computing if need and returns value for this target
If any dependence of this target of any dependencies of dependencies were
recomputed this target will be recomputed too.

=item touch( $target )

This method refreshes the time of this target. Here is analogy with L<touch>
utility of Unix and behaviour as L<make> after it. After L</touch> all targets
are dependent from this target will be recomputed at next L</run> with an
appropriate ones.

=item target_remove ( $target )

It's like a removing of target file in make. You can force to recompute target
by this method. It will remove target marker if one exists and once when cascade
will need target value it will be recomputed. In a during recomputing of course
cascade will return an old value if one exists in cache.

=back

=head1 STATUS

This module is experimental and not finished for new features ;-)
Please send me issues through L<https://github.com/Perlover/CHI-Cascade> page

=head1 ANALOGIES WITH make

Here simple example how it works. Here is a direct analogy to Unix make
utility:

    In CHI::Cascade:		In make:

    rule			rule
    depends			prerequisites
    code			commands
    run( rule_name )		make target_name

=head1 FEATURES

The features of this module are following:

=over

=item Computing inside process

If module needs to compute item for cache we compute inside process (no forks)
For web applications it means that one process for one request could take
a some time for computing. But other processes will not wait and will get either
old previous computed value or I<undef> value.

=item Non-blocking computing for concurrent processes

If other process want to get data from cache we should not block it. So
concurrent process can get an old data if new computing is run or can get
I<undef> value. A concurrent process should decide itself what it should do
after it - try again after few time or print some message like 'Please wait and
try again' to user.

=item Each target is splitted is two items in cache

For optimization this module keeps target's info by separately from value item.
A target item has lock & timestamp fields. A value item has a computed value.

=back

=head1 EXAMPLE

For example please to see the SYNOPSIS

When we prepared a rules and a depends we can:

If unique_name_other1 and/or unique_name_other2 are(is) more newer than
unique_name the unique_name will be recomputed.
If in this example unique_name_other1 and unique_name_other2 are older than
unique_name but the unique_name_other3 is newer than unique_name_other1 then
unique_name_other1 will be recomputed and after the unique_name will be
recomputed.

And even we can have a same rule:

    $cascade->rule(
	target	=> qr/^unique_name_(.*)$/,
	depends	=> sub { 'unique_name_other_' . $_[0] },
	code	=> sub {
	    my ($rule, $target_name, $values_of_depends) = @_;

	    # $rule->qr_params		=== ( 3 )
	    # $target_name		== 'unique_name_3' if $cascade->run('unique_name_3') was
	    # $values_of_depends	== {
	    #     unique_name_other_3	=> $value_ref_3
	    # }
	}
    );

    $cascade->rule(
	target	=> qr/unique_name_other_(.*)/,
	code	=> sub {
	    my ($rule, $target_name, $values_of_depends) = @_;
	    ...
	}
    );

When we will do:

    $cascade->run('unique_name_52');

$cascade will find rule with qr/^unique_name_(.*)$/, will make =~ and will find
a depend as unique_name_other_52

=head1 AUTHOR

This module has been written by Perlover <perlover@perlover.com>

=head1 LICENSE

This module is free software and is published under the same terms as Perl
itself.

=head1 SEE ALSO

=over

=item L<CHI::Cascade::Rule>

An instance of this object can be used in your target codes.

=item L<CHI>

This object is used for cache.

=item L<CHI::Driver::Memcached::Fast>

Recommended if you have the Memcached

=item L<CHI::Driver::File>

Recommended if you want to use the file caching instead the Memcached for
example

=back

=cut
